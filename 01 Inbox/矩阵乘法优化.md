---
tags:
  - gemm
  - GOTO
title: 矩阵乘法优化
date: 2024-04-25 10:29
---

---

## 1. 基本的技巧

### a. 使用指针

矩阵的寻址在不考虑编译器优化的前提下，这部分耗时可以通过指针的形式进行优化。

```C++
double *cp;

for ( j = 0; j < n; j ++ ) {
	cp = &C[ j * ldc ];          // point cp to top of jth column
	for ( i = 0; i < m; i ++ ) {
		*cp++ = 0.0;             // set the element that cp points to to zero and
		                         // advance the pointer.
	}
}
```

### b. 循环展开

```C++
double *cp;

for ( j = 0; j < n; j ++ ) {
	cp = &C[ j * ldc ];
	for ( i = 0; i < m; i += 4 ) {
		*(cp+0) = 0.0;
		*(cp+1) = 0.0;
		*(cp+2) = 0.0;
		*(cp+3) = 0.0;
		cp += 4;
	}
}
```

循环展开带来的好处：

- i 以及 cp 每隔 4 次迭代才更新一次
- * (cp+0) 使用了间接寻址策略，要远比 \* (cp+k) 高效，当 k 为变量的时候
- cache line 的因素，将内存数据拷贝到缓存中时，操作系统是会拷贝 64 字节的数据，因此访问内存连续的数据将会减少内存的拷贝次数

### 寄存器变量

使用寄存器变量将特定的数据保存在寄存器中

```C++
double *cp;

for ( j = 0; j < n; j ++ ) {

	cp = &C[ j * ldc ];
	for ( i = 0; i < m; i += 4 ) {
		register double c0=0.0, c1=0.0, c2=0.0, c3=0.0;
		*(cp+0) = c0;
		*(cp+1) = c1;
		*(cp+2) = c2;
		*(cp+3) = c3;
		cp += 4;
	}
}
```

## 矩阵分块

在现代的基于缓存的架构中，计算效率很大程度上受到数据在内存层之间移动成本的影响。因为数据从内存到处理器的传输速度远低于处理器处理数据的速度，因此需要特别注意如何减少这种数据移动的开销。

解决这一问题的方法之一是只对执行矩阵乘法的核心代码（即“内核”）进行高度优化。这种内核通常只处理相对较小的矩阵。对于更大的矩阵，我们可以采用分块技术，即将大矩阵分解成小块，然后用这个高度优化的内核来处理这些小块。这样做的好处是，可以有效控制数据在内存层之间的移动，从而降低总体的计算成本，提高效率。

这种思路背后的核心观点是：通过优化处理小规模问题的内核，再通过智能地组织数据和任务分配，使得这种优化可以扩展到更大规模的问题上，从而无需为每种规模的问题重新进行繁琐的优化。这样可以在保持高性能的同时，减少开发和维护的复杂度。